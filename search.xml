<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[七牛云多文件上传格式不正确导致上传中断]]></title>
      <url>/2017/12/18/%E4%B8%83%E7%89%9B%E4%BA%91%E4%B8%8A%E4%BC%A0bug/</url>
      <content type="html"><![CDATA[<p>开发者基于JS-JDK可以方便的从浏览器端上传文件至七牛云存储，并对上传成功后的图片进行丰富的数据处理操作</p>
<blockquote>
<p>详见<a href="https://github.com/qiniu/js-sdk#faq" target="_blank" rel="external">https://github.com/qiniu/js-sdk#faq</a></p>
</blockquote>
<p>开发中发现的问题是：当我在文件过滤的时候限制某格式的上传（如下代码所示），当我选择不符合规格的文件时，qiniu会直接走ERROR，并中止当前正在上传的文件，直接执行下一份文件，直至所有文件都上传完毕。但是被中止的这份文件是无辜的，我们得让它跟上大部队的步伐。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">var uploader = Qiniu.uploader(&#123;</div><div class="line">    filters: &#123; </div><div class="line">        max_file_size: &apos;150mb&apos;, //最大文件体积限制</div><div class="line">        prevent_duplicates: true,</div><div class="line">        // 限制可以上传的文件格式 </div><div class="line">        mime_types: [&#123;</div><div class="line">                title: &quot;video files&quot;,</div><div class="line">                extensions: &quot;mp4,avi,mkv,wmv,flv&quot; </div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                title: &quot;audio files&quot;,</div><div class="line">                extensions: &quot;mp3&quot;</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                title: &quot;image files&quot;,</div><div class="line">                extensions: &quot;jpg,jpeg,png,gif,bmp&quot;</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                title: &quot;word files&quot;,</div><div class="line">                extensions: &quot;doc,docx,ppt,pptx,xls,xlsx,csv,pdf,wps,et,dps,application/x-ppt&quot; //因上传组件自定义格式支持有限，部分格式文件不显示，故最后一项使其不能识别，则显示全部文件。</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;,</div><div class="line">    init: &#123;</div><div class="line">            &apos;FilesAdded&apos;: function(up, files) &#123;</div><div class="line">                plupload.each(files, function(file) &#123;</div><div class="line">                    // 文件添加进队列后,处理相关的事情</div><div class="line">                &#125;);</div><div class="line">            &#125;,</div><div class="line">            &apos;BeforeUpload&apos;: function(up, file) &#123;</div><div class="line">                // 每个文件上传前,处理相关的事情</div><div class="line">            &#125;,</div><div class="line">            &apos;UploadProgress&apos;: function(up, file) &#123;</div><div class="line">                // 每个文件上传时,处理相关的事情</div><div class="line">            &#125;,</div><div class="line">            &apos;FileUploaded&apos;: function(up, file, info) &#123;</div><div class="line">                // 每个文件上传成功后,处理相关的事情</div><div class="line">            &#125;,</div><div class="line">            &apos;Error&apos;: function(up, err, errTip) &#123;</div><div class="line">                //上传出错时,处理相关的事情</div><div class="line">            &#125;,</div><div class="line">            &apos;UploadComplete&apos;: function() &#123;</div><div class="line">                //队列文件处理完毕后,处理相关的事情</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>解决思路<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&apos;FileUploaded&apos;: function(up, file, info) &#123;</div><div class="line">    // 给每个上传成功的文件加一个标记类</div><div class="line">    $(&apos;#&apos;+file.id).addClass(&apos;finished&apos;);</div><div class="line">&#125;,</div><div class="line">&apos;UploadComplete&apos;: function() &#123;</div><div class="line">    // 当队列显示全部处理完后，循环检测一遍数据，是否有未完成标记,有则重新执行，重新执行过程中会自动跳过已成功的文件，从而达到全部上传的效果。</div><div class="line">    plupload.each(files, function (file) &#123;</div><div class="line">        if (!$(&apos;#&apos; + file.id).hasClass(&apos;finished&apos;)) &#123;</div><div class="line">            uploader.start();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> dailyBugs </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo+gihub简易搭建个人博客]]></title>
      <url>/2017/10/17/hexo+github%E7%AE%80%E6%98%93%E6%90%AD%E5%BB%BAblog/</url>
      <content type="html"><![CDATA[<p>这篇实在太全，感谢原作者，需要请戳：<br><a href="http://www.cnblogs.com/dantefung/p/d8c48ba8030bcab7cfc364d423186fee.html" target="_blank" rel="external">http://www.cnblogs.com/dantefung/p/d8c48ba8030bcab7cfc364d423186fee.html</a></p>
]]></content>
      
        <categories>
            
            <category> 个人收藏 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[客户端向服务器发起http请求的请求信息详解]]></title>
      <url>/2017/05/27/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E7%9A%84%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF/</url>
      <content type="html"><![CDATA[<h3 id="一个完整的HTTP请求例子："><a href="#一个完整的HTTP请求例子：" class="headerlink" title="一个完整的HTTP请求例子："></a>一个完整的HTTP请求例子：</h3><p>请求方法:<br>GET/sample.jsp   HTTP/1.1   (方法 / url / 协议 / 版本)<br>请求头:<br> Accept:image/gif.image/jpeg,<em>/</em>   (告诉WEB服务器自己接受什么介质类型，<em>/</em> 表示任何类型，type/* 表示该类型下的所有子类型)<br>Accept-Language:zh-cn   (浏览器申明自己接收的语言 )<br>Connection:Keep-Alive<br>Host:localhost<br>User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)<br>Accept-Encoding:gzip,deflate   (浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）)<br>请求正文: 包含客户提交的查询字符串信息<br>username=laipp&amp;password=123456</p>
<h3 id="详解-keep-alive"><a href="#详解-keep-alive" class="headerlink" title="详解 keep-alive"></a>详解 keep-alive</h3><p>HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive性能更高,因为避免了建立/释放连接的开销<br><img src="../images/http1.jpg" alt="keep-alive"></p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>第一次(客户端向服务器端say hi)<br>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。<br>第二次(服务器端跟客户端说:我收到你的sayhello了,你可以开始发请求了)<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次(客户端向服务器端说:好的 !)<br>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。<br><img src="../images/http2.gif" alt=""></p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次挥手”。<br>1.第一次挥手：主机1(可以使客户端，也可以是服务器端)，设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段;此时，主机1进入FIN_WAIT_1状态;这表示主机1没有数据要发送给主机2了;<br>2.第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1;主机1进入FIN_WAIT_2状态;主机2告诉主机1，我也没有数据要发送了，可以进行关闭连接了;<br>3.第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入CLOSE_WAIT状态;<br>4.第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态;主机2收到主机1的ACK报文段以后，就关闭连接;此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。<br>至此，TCP的四次挥手就这么愉快的完成了。<br>大白话解释 :<br> 断开的时候,没有指定一定是客户端才能发出断开请求.谁都可以.<br> 第一步: A跟B说:我要断开请求了;<br> 第二步: B跟A说:我收到你的断开请求了.但是我还有数据没有发给你;<br> 第三步: B跟A说:我的数据发完了,可以断开请求了;<br> 第四步: A跟B说: 收到,断开!;<br> <img src="../images/http3.gif" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu+nginx 下小幺鸡的安装]]></title>
      <url>/2017/05/24/ubuntu+nginx%20%E4%B8%8B%E5%B0%8F%E5%B9%BA%E9%B8%A1%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>本人最近尝试了在ubuntu下配置 www.xiaoyaoji.com.cn 接口文档环境, 想说从此以后跟后端的交互就靠着这个, 实现高效沟通.<br>老大对我找的接口文档要求,就是能够本地部署,支持二次开发.小幺鸡恰好符合.</p>
<p>小幺鸡文档环境配置要求:</p>
<blockquote>
<p> jdk1.7以上   tomcat7以上  mysql5.5以上</p>
</blockquote>
<h3 id="先装jdk环境"><a href="#先装jdk环境" class="headerlink" title="先装jdk环境"></a>先装jdk环境</h3><p>1.查看linux下的jdk版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ java --version</div></pre></td></tr></table></figure></p>
<p>这时候默认的可能是显示默认的openJDK:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">OpenJDK Runtime Environment (build 1.6.0-b09)</div><div class="line">OpenJDK 64-Bit Server VM (build 1.6.0-b09, mixed mode)</div></pre></td></tr></table></figure></p>
<p>2.你可以选择卸载掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get remove openjdk*</div></pre></td></tr></table></figure></p>
<p>3.选择适合自己的jdk</p>
<p>你需要下载jdk，建议在Oracle的官网下载，以下是各个版本的最新版本的下载链接：<br>jdk1.6（Linux 64位）的最新版本：<a href="http://download.oracle.com/otn/java/jdk/6u45-b06/jdk-6u45-linux-x64.bin?AuthParam=1469888144_a5888dc2ddea46a4bd983fc8e323dde6" target="_blank" rel="external">http://download.oracle.com/otn/java/jdk/6u45-b06/jdk-6u45-linux-x64.bin?AuthParam=1469888144_a5888dc2ddea46a4bd983fc8e323dde6</a></p>
<p>jdk1.7的最新版本（linux 64位）：<a href="http://download.oracle.com/otn/java/jdk/7u80-b15/jdk-7u80-linux-x64.tar.gz?AuthParam=1469888541_713e4316772da5ea5e020cf6f091c32f" target="_blank" rel="external">http://download.oracle.com/otn/java/jdk/7u80-b15/jdk-7u80-linux-x64.tar.gz?AuthParam=1469888541_713e4316772da5ea5e020cf6f091c32f</a></p>
<p>jdk1.8的最新版本（linux64位）：<a href="http://download.oracle.com/otn/java/jdk/8u92-b14/jdk-8u92-linux-x64.tar.gz?AuthParam=1469888482_dc98c0ed2225048dd3264442cacfa96b" target="_blank" rel="external">http://download.oracle.com/otn/java/jdk/8u92-b14/jdk-8u92-linux-x64.tar.gz?AuthParam=1469888482_dc98c0ed2225048dd3264442cacfa96b</a></p>
<p>用wget方式分别下载到/usr/lib/Java目录下（如果没有java目录，用以下命令进行创建sudo mkdir /usr/lib/java）<br>(如果命令安装太慢,可以直接下载包再移进去)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo wget http://download.oracle.com/otn/java/jdk/6u45-b06/jdk-6u45-linux-x64.bin?AuthParam=1469888144_a5888dc2ddea46a4bd983fc8e323dde6</div><div class="line">sudo wget http://download.oracle.com/otn/java/jdk/7u80-b15/jdk-7u80-linux-x64.tar.gz?AuthParam=1469888541_713e4316772da5ea5e020cf6f091c32f</div><div class="line">sudo wget http://download.oracle.com/otn/java/jdk/8u92-b14/jdk-8u92-linux-x64.tar.gz?AuthParam=1469888482_dc98c0ed2225048dd3264442cacfa96b</div></pre></td></tr></table></figure></p>
<p>下载完成后,你得到的是一个压缩包,解压到：/usr/lib/Java目录下。<br>前面你只是解压了jdk到某个目录下，如果想使用某个jdk版本，还必须修改环境，使其指向要使用的jdk版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/profile</div></pre></td></tr></table></figure></p>
<p>在这个文件的末尾加上(修改你的yourjdkfoldername)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export JAVA_HOME=/usr/lib/java/yourjdkfoldername</div><div class="line">export CLASSPATH=$&#123;JAVA_HOME&#125;/lib</div><div class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</div></pre></td></tr></table></figure></p>
<p>然后执行以下命令使其生效，查看jdk是否生效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">source ~/.profile</div><div class="line">java --version</div></pre></td></tr></table></figure></p>
<p>如果显示不再是openjdk<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java version &quot;1.8.0_131&quot;</div><div class="line">Java(TM) SE Runtime Environment (build 1.8.0_131-b11)</div><div class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)</div></pre></td></tr></table></figure></p>
<p>那么到此,你的jdk就安装就完成了!</p>
<h3 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h3><p>装部署tomcat之前必须先安装好JDK或JRE的环境.JRE是java程序运行的基础,而jdk是给开发java程序的人员提供了包括jre在内的基本环境以及一些开发工具.</p>
<blockquote>
<p>详见: <a href="http://note.youdao.com/groupshare/?token=A8B52AEB48B74FCEB286A5A8766C8AA9&amp;gid=29536445" target="_blank" rel="external">http://note.youdao.com/groupshare/?token=A8B52AEB48B74FCEB286A5A8766C8AA9&amp;gid=29536445</a></p>
</blockquote>
<ol>
<li><p>创建tomcat用户</p>
<blockquote>
<p>为了安全考虑，Tomcat 需要以普通用户的权限来运行。所以我们将创建一个用户和用户组，来运行 Tomcat 服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">创建tomcat用户组</div><div class="line">$ sudo groupadd tomcat</div><div class="line">创建tomcat用户,用户主目录为 /etc/tomcat ，这个目录也是我们将用来安装 tomcat 的目录（当然也可以是你喜欢的其他目录）</div><div class="line">$ sudo useradd -s /bin/false -g tomcat -d /etc/tomcat tomcat</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>下载tomcat <a href="http://www.apache.org/tomcat/" target="_blank" rel="external">http://www.apache.org/tomcat/</a> 并安装到 /etc/下</p>
<blockquote>
<p>用户 tomcat 需要有合适的权限来运行Tomcat 服务，所以接下来需要设置用户权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ cd /etc/tomcat</div><div class="line">给用户conf的写入权限,以及对子目录的读权限</div><div class="line">$ sudo chgrp -R tomcat conf</div><div class="line">$ sudo chmod g+rwx conf</div><div class="line">$ sudo chmod g+r conf/*</div><div class="line">设置tomcat用户对 work/ temp/ logs/这几个目录的所有权</div><div class="line">sudo chown -R tomcat work/ temp/ logs/</div><div class="line">修改 /etc/init/tomcat.conf </div><div class="line">env JAVA_HOME=/usr/lib/jvm/yourjdkfoldername/jre</div><div class="line">env CATALINA_HOME=/etc/tomcat</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>修改环境变量</p>
<p>将以下的变量配置放在之前配置jdk环境变量的后面即可，如下：<br>在目录/etc下修改profile文件，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">命令: vi /etc/profile</div><div class="line">将下列配置写到该文件下</div><div class="line">export CATALINA_HOME=/etc/tomcat</div><div class="line">export CLASSPATH=.:$JAVA_HOME/lib:$CATALINA_HOME/lib</div><div class="line">export PATH=$PATH:$CATALINA_HOME/bin</div><div class="line"></div><div class="line">配置完成之后执行命令：source /etc/profile，</div><div class="line">如果没有提示错误，证明配置ok</div><div class="line">可以通过echo $CLASSPATH来查看环境配置</div></pre></td></tr></table></figure>
</li>
<li><p>重启tomcat script</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo initctl reload-configuration</div><div class="line">$ sudo initctl start tomcat</div></pre></td></tr></table></figure>
</li>
<li><p>执行sh catalina.sh或者sh startup.sh</p>
</li>
<li><p>提示如下信息表示配置ok：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Using CATALINA_BASE:   /etc/tomcat</div><div class="line">Using CATALINA_HOME:   /etc/tomcat</div><div class="line">Using CATALINA_TMPDIR: /etc/tomcat/temp</div><div class="line">Using JRE_HOME:        /usr/jdk1.8.0_131</div><div class="line">Using CLASSPATH:       /etc/tomcat/bin/bootstrap.jar</div></pre></td></tr></table></figure>
</li>
<li><p>先再虚拟机上访问访问tomcat首页,如果正常显示tomcat首页表明配置ok。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl http://localhost：8080/</div></pre></td></tr></table></figure>
</li>
<li><p>有可能因为8080端口被占用而启动失败</p>
<blockquote>
<p>解决办法: 到  /etc/tomcat/conf/server.xml去修改端口配置(我是将8080改为9009)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Connector port=&quot;9009&quot; protocol=&quot;HTTP/1.1&quot;</div><div class="line">           connectionTimeout=&quot;20000&quot;</div><div class="line">           redirectPort=&quot;8443&quot; /&gt;</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>在虚拟机上你能够访问 <a href="http://localhost：9009/" target="_blank" rel="external">http://localhost：9009/</a> 但是主机上不能访问</p>
<blockquote>
<p>在Vagrantfile上配置端口映射,设定语法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">  将主机上的9009请求都转发到虚拟机上的9009端口进行处理</div><div class="line">config.vm.network :forwarded_port, guest: 9009, host: 9009</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<p>于是你可以在主机上 打开 <a href="http://localhost:9009/访问tomcat页面了" target="_blank" rel="external">http://localhost:9009/访问tomcat页面了</a></p>
<h3 id="在tomcat下配置小幺鸡"><a href="#在tomcat下配置小幺鸡" class="headerlink" title="在tomcat下配置小幺鸡"></a>在tomcat下配置小幺鸡</h3><p>可直接参考官方文档: </p>
<blockquote>
<p><a href="http://git.oschina.net/zhoujingjie/apiManager" target="_blank" rel="external">http://git.oschina.net/zhoujingjie/apiManager</a></p>
</blockquote>
<h3 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h3><p>到这步都默认你可以用: <a href="http://localhost:9009/" target="_blank" rel="external">http://localhost:9009/</a> 打开小幺鸡了<br>但是我想试试用nginx代理下tomcat(此步多余,仅为个人练习)</p>
<ol>
<li><p>到 /etc/nginx/sites-available</p>
<blockquote>
<p>sites-available是我们的虚拟主机的目录，我们在在这里面可以创建多个虚拟主机.</p>
</blockquote>
</li>
<li><p>创建一个xiaoyaoji-api.com的虚拟主机</p>
</li>
<li><p>修改xaoyaoji-api.com里的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">命令: vim xiaoyaoji-api.com</div><div class="line">里面的配置如下:</div><div class="line">server &#123;</div><div class="line">        listen 80; </div><div class="line">        server_name xiaoyaoji-api.com;</div><div class="line">    </div><div class="line">        root /etc/tomcat/webapps/ROOT;</div><div class="line">        index index.html index.htm index.php;</div><div class="line"></div><div class="line">        # Make site accessible from http://localhost/</div><div class="line">        #server_name localhost;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">                proxy_pass http://127.0.0.1:9009/;</div><div class="line">                index index.php index.html;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>软连接到sites-enabled </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">命令: ln -s /etc/nginx/sites-available/xiaoyaoji-api.com /etc/nginx/sites-enabled/xiaoyaoji-api.com</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>sites-enabled的配置文件其实就是sites-available里面的配置文件的软连接,但是由于nginx.conf默认包含的是这个文件夹,所以我们在sites-available里面建立了新的站点之后,还要建立个软连接到sites-enabled里面才行.</p>
</blockquote>
<ol>
<li>再去本地的 /etc/host文件下加上以下配置,就可以通过域名访问小幺鸡啦!<blockquote>
<p>127.0.0.1 xiaoyaoji-api.com </p>
</blockquote>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6 之 let & var & const]]></title>
      <url>/2017/04/12/ES6-1%20let&amp;var/</url>
      <content type="html"><![CDATA[<h2 id="JS-是没有块级作用域的"><a href="#JS-是没有块级作用域的" class="headerlink" title="JS 是没有块级作用域的"></a>JS 是没有块级作用域的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var arr = [];</div><div class="line">for (var i = 0; i &lt; 10; i++) &#123;</div><div class="line">  arr[i] = function () &#123;</div><div class="line">    return i;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">arr[3](); // 10</div></pre></td></tr></table></figure>
<p>因为 ES5 及之前是没有块级作用域的，i 所处的仍是全局作用域而不是块级作用域。因此，循环过程中数组 arr 的每个数组项所引用的函数中的变量 i 都是引用全局作用域中的 i，因此 arr3 中 i 为 for 循环结束时的 i 的值 10。</p>
<h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>利用匿名函数的自我执行。这个时候的 i 只是函数参数，而函数参数是按值传递的（不是按引用传递），所以这个时候匿名函数被强制执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var arr = [];</div><div class="line">for (var i = 0; i &lt; 10; i++) &#123;</div><div class="line">    arr[i] = function(num)&#123;</div><div class="line">        return function()&#123;</div><div class="line">            return num;</div><div class="line">        &#125;</div><div class="line">    &#125;(i);</div><div class="line">&#125;</div><div class="line">arr[3](); // 3</div></pre></td></tr></table></figure>
<p>ES5 中在 for、if、while 等语句内部的声明的变量与在外部声明是一样的，在这些语句外部也可以访问和修改这些变量的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function fun() &#123;</div><div class="line">    if(0 &lt; 2) &#123;</div><div class="line">        var name = &quot;jeri&quot;;</div><div class="line">    &#125;  </div><div class="line">    console.log(name); // jeri</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="let-的出现使得-JavaScript-终于拥有了块级作用域。"><a href="#let-的出现使得-JavaScript-终于拥有了块级作用域。" class="headerlink" title="let 的出现使得 JavaScript 终于拥有了块级作用域。"></a>let 的出现使得 JavaScript 终于拥有了块级作用域。</h2><p>当我们在一个代码块中使用 let 来声明变量，通过 let 声明的变量只在当前块作用域中有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    let a = 1;</div><div class="line">    var b = 2;</div><div class="line">&#125;</div><div class="line">console.log(a); //ReferenceError</div><div class="line">console.log(b); //2</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">    let a = 1;</div><div class="line">    if(true)&#123;</div><div class="line">        let a = 2;</div><div class="line">        console.log(a); //2</div><div class="line">    &#125;</div><div class="line">    console.log(a); //1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="let-没有变量提升"><a href="#let-没有变量提升" class="headerlink" title="let 没有变量提升"></a>let 没有变量提升</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">(function()&#123;</div><div class="line">   alert(a);</div><div class="line">   var a = 2;</div><div class="line">&#125;)();//结果：undefined</div></pre></td></tr></table></figure>
<p>因为 var 的变量提升,上面代码等同于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">(function()&#123;</div><div class="line">   var a;</div><div class="line">   alert(a);</div><div class="line">   a = 2;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>而 let</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">(function()&#123;</div><div class="line">   alert(a);</div><div class="line">   let a = 2;</div><div class="line">&#125;)();   // 结果：报错a未定义</div></pre></td></tr></table></figure>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>即constant常量</p>
<ul>
<li><p>不可修改,不可重复声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const NAME = &apos;lpp&apos;;</div><div class="line">const NAME = &apos;AB&apos;; // Error</div><div class="line">NAME = &apos;apple&apos;; // Error</div></pre></td></tr></table></figure>
</li>
<li><p>只在块级作用域起作用，这点与let关键字一样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    const NAME = &apos;lpp&apos;;</div><div class="line">&#125;</div><div class="line">console.log(NAME); // Error</div></pre></td></tr></table></figure>
</li>
<li><p>不存在变量提升，必须先声明后使用，跟let关键字一样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(NAME); // Error</div><div class="line">const NAME = &apos;lpp&apos;;</div></pre></td></tr></table></figure>
</li>
<li><p>声明后必须要赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const NAME; // Error</div></pre></td></tr></table></figure>
</li>
<li><p>对象赋值后可以修改，因为对象存的是地址。</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Git-2个分支间的切换保存]]></title>
      <url>/2017/03/27/Git-2%E4%B8%AA%E5%88%86%E6%94%AF%E9%97%B4%E7%9A%84%E5%88%87%E6%8D%A2%E4%BF%9D%E5%AD%98/</url>
      <content type="html"><![CDATA[<p>最近我们公司要对项目某部分进行代码重构，但是时不时又会有新的需求更开发。于是有了在两个分支之间游走切换的问题，在refactoring上进行重构，在master上进行原项目的新需求开发。</p>
<h3 id="新建refactorig分支并推送到远程仓库"><a href="#新建refactorig分支并推送到远程仓库" class="headerlink" title="新建refactorig分支并推送到远程仓库"></a>新建refactorig分支并推送到远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">创建并切换到此分支</div><div class="line">git branch refactoring</div><div class="line">git checkout -b refactoring</div><div class="line"></div><div class="line">// or</div><div class="line"></div><div class="line">git checkout -b refactoring   </div><div class="line"></div><div class="line">then推送到远程仓库</div><div class="line"></div><div class="line">git push orgin refactoring</div></pre></td></tr></table></figure>
<h3 id="新建了分支到远程仓库，但是你本地git-branch-查不到？"><a href="#新建了分支到远程仓库，但是你本地git-branch-查不到？" class="headerlink" title="新建了分支到远程仓库，但是你本地git branch 查不到？"></a>新建了分支到远程仓库，但是你本地git branch 查不到？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git fetch origin refacoring</div><div class="line">git branch refacoring</div><div class="line"></div><div class="line">or</div><div class="line"></div><div class="line">git fetch origin refacoring:refacoring</div></pre></td></tr></table></figure>
<blockquote>
<p>使用远程refacoring分支在本地创建refacoring(但不会切换到该分支),<br>如果本地不存在refacoring分支, 则会自动创建一个新的refacoring分支,<br>如果本地存在refacoring分支, 并且是`fast forward’, 则自动合并两个分支, 否则, 会阻止以上操作。</p>
</blockquote>
<p>当我在进行重构的时候，这时候新需求下来了，我肯定得去先把新需求搞定吧，但是我的重构某一功能写到一半，还没测试，push上去恐怕会影响到别人，那肿办？</p>
<h3 id="切换保存"><a href="#切换保存" class="headerlink" title="切换保存"></a>切换保存</h3><h4 id="（一）"><a href="#（一）" class="headerlink" title="（一）"></a>（一）</h4><ul>
<li>先把正在进行的refactoring </li>
<li>commit掉</li>
<li>不push</li>
<li>切换到 master分支  git checkout master</li>
<li>做完了commit </li>
<li>再切回去你的refactoring</li>
</ul>
<blockquote>
<p>这是理想的办法，互不影响。<br>别担心refactoring和master的本地代码会互相影响到，你切换分支的时候，本地代码也会切换的。</p>
</blockquote>
<h4 id="（二）使用git-stash"><a href="#（二）使用git-stash" class="headerlink" title="（二）使用git stash"></a>（二）使用git stash</h4><p>先把正在进行的refactoring：</p>
<ul>
<li>git stash / git stash save “修改的信息”<br>( 这样以后你的代码就回到了自己上一个commit了，直接git stash的话git stash的栈会给你一个hash值作为版本说明，如果你有填写“修改的信息”，git stash的栈会把你填写的信息作为版本的说明。)</li>
<li>接下来你回到master分支修改完成，你又再回到refactoring分支，输入</li>
<li>git stash pop / git stash list ( 就可以回到保存的版本了。git stash pop的作用是将git stash栈中最后一个版本取出来。)</li>
</ul>
<h3 id="合并问题"><a href="#合并问题" class="headerlink" title="合并问题"></a>合并问题</h3><ul>
<li>master 进化到了 master2</li>
<li>refactoring 进化到了 refactoring2</li>
</ul>
<h4 id="方法1：直接merge"><a href="#方法1：直接merge" class="headerlink" title="方法1：直接merge"></a>方法1：直接merge</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git checkout master</div><div class="line">git merge refactoring</div><div class="line"></div><div class="line">然后安心删除refactoring分支</div><div class="line">git branch -d refactoring</div></pre></td></tr></table></figure>
<h4 id="方法2：让分支历史看起来像没有经过任何合并一样"><a href="#方法2：让分支历史看起来像没有经过任何合并一样" class="headerlink" title="方法2：让分支历史看起来像没有经过任何合并一样"></a>方法2：让分支历史看起来像没有经过任何合并一样</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout refactoring</div><div class="line">git rebase origin</div></pre></td></tr></table></figure>
<blockquote>
<p>这些命令会把你的”refactoring”分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到”.git/rebase”目录中),然后把”refactoring”分支更新 为最新的”origin”分支，最后把保存的这些补丁应用到”refactoring”分支上。</p>
</blockquote>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">解决冲突 手动解决</div><div class="line">再 git add .</div><div class="line">git commit</div></pre></td></tr></table></figure>
<h4 id="rebase的过程中，也许会出现冲突-conflict"><a href="#rebase的过程中，也许会出现冲突-conflict" class="headerlink" title="rebase的过程中，也许会出现冲突(conflict)"></a>rebase的过程中，也许会出现冲突(conflict)</h4><p>在这种情况，Git会停止rebase并会让你去解决 冲突；在解决完冲突后，用”git-add”命令去更新这些内容的索引(index), 然后，你无需执行 git-commit,只要执行:<br>$ git rebase –continue<br>这样git会继续应用(apply)余下的补丁。<br>在任何时候，你可以用–abort参数来终止rebase的行动，并且”refactoring” 分支会回到rebase开始前的状态。<br>$ git rebase –abort</p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[浅拷贝与深拷贝]]></title>
      <url>/2017/03/15/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
      <content type="html"><![CDATA[<p>最近接到一个需求，做一个学生答题成绩统计页，教师停留在统计查看页面时，能实时看到该班学生们的答题信息。由于页面有些进度条的加载效果，所以就不会每请求一次接口都重绘页面，只检测到数据有变化时才重绘。</p>
<p>所以现在设计成了每10s请求一次接口，将新数据与旧数据进行比较，判断是否有变化，有则重绘页面。</p>
<p>那么，如何将旧数据存储起来，再进行比较呢？</p>
<p>这就涉及数据的拷贝，我们现在就需要对一个object对象进行深拷贝，在这之前，我们可能会趟到浅拷贝的误区 。</p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>浅拷贝是指源对象与拷贝对象共用一份实体，仅仅是引用的变量不同（名称不同），对其中任何一个对象的改动都会影响另外一个对象。<br>举个例子，一个人一开始叫张三，后来改名叫李四了，可是还是同一个人，不管是张三缺胳膊少腿还是李四缺胳膊少腿，都是这个人倒霉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var obj1 = &#123;</div><div class="line">    &apos;name&apos;: &apos;张三&apos;,</div><div class="line">    &quot;leg&quot;: &#123;</div><div class="line">        &quot;status&quot;: &quot;good&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var obj2 = obj1;</div><div class="line">obj2.name = &apos;李四&apos;;</div><div class="line">obj2.leg.status = &apos;broken&apos;;</div><div class="line"></div><div class="line">console.log(obj1) // &#123; name: &apos;李四&apos;, leg: &#123; status: &apos;broken&apos; &#125; &#125;</div><div class="line">console.log(obj2) // &#123; name: &apos;李四&apos;, leg: &#123; status: &apos;broken&apos; &#125; &#125;</div></pre></td></tr></table></figure></p>
<p>因为浅拷贝只会将对象的各个属性进行依次复制，并不会进行递归复制，而 JavaScript 存储对象都是存地址的，所以浅拷贝会导致 obj1.leg 和 obj2.leg 指向同一块内存地址,例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 假的深拷贝,只实现了第一层属性的拷贝</div><div class="line">var obj2 = Object.assign(&#123;&#125;,obj1);</div><div class="line">obj2.name = &apos;李四&apos;;</div><div class="line">obj2.leg.status =  &apos;broken&apos;;</div><div class="line"></div><div class="line">console.log(obj1) // &#123; name: &apos;张三&apos;, leg: &#123; status: &apos;broken&apos; &#125; &#125;</div><div class="line">console.log(obj2) // &#123; name: &apos;李四&apos;, leg: &#123; status: &apos;broken&apos; &#125; &#125;</div></pre></td></tr></table></figure></p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>深拷贝是指源对象与拷贝对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。</p>
<p>举个例子，一个人名叫张三，后来用他克隆（假设法律允许）了另外一个人，叫李四，不管是张三缺胳膊少腿还是李四缺胳膊少腿都不会影响另外一个人。</p>
<h3 id="实现深拷贝的方式"><a href="#实现深拷贝的方式" class="headerlink" title="实现深拷贝的方式"></a>实现深拷贝的方式</h3><p>1.简单粗暴的先把对象转成字符串，再把字符串转成对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var obj2 = JSON.parse(JSON.stringify(obj1));</div><div class="line">console.log(obj1) // &#123; name: &apos;张三&apos;, leg: &#123; status: &apos;good&apos; &#125; &#125;</div><div class="line">console.log(obj2) // &#123; name: &apos;李四&apos;, leg: &#123; status: &apos;broken&apos; &#125; &#125;</div></pre></td></tr></table></figure></p>
<p>2、利用递归来实现深拷贝，如果对象属性的值是引用类型（Array,Object），那么对该属性进行深拷贝，直到遍历到属性的值是基本类型为止<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function deepClone(obj) &#123;</div><div class="line">    if (!obj &amp;&amp; typeof obj !== &apos;object&apos;) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    var newObj = obj.constructor === Array ? [] : &#123;&#125;;</div><div class="line">    for (var key in obj) &#123;</div><div class="line">        if (obj[key]) &#123;</div><div class="line">            if (obj[key] &amp;&amp; typeof obj[key] === &apos;object&apos;) &#123;</div><div class="line">                newObj[key] = obj[key].constructor === Array ? [] : &#123;&#125;;</div><div class="line">                // 递归</div><div class="line">                newObj[key] = deepClone(obj[key]);</div><div class="line">            &#125; else &#123;</div><div class="line">                newObj[key] = obj[key]</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return newObj;</div><div class="line">&#125;</div><div class="line">var obj2 = deepClone(obj1);</div><div class="line">console.log(obj1) // &#123; name: &apos;张三&apos;, leg: &#123; status: &apos;good&apos; &#125; &#125;</div><div class="line">console.log(obj2) // &#123; name: &apos;李四&apos;, leg: &#123; status: &apos;broken&apos; &#125; &#125;</div></pre></td></tr></table></figure></p>
<p>实现了深拷贝，我们就可以对obj1和obj2进行比较,判断是否相等了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(obj1 === obj2)  // false;</div><div class="line">console.log(obj1 == obj2)  // false;</div></pre></td></tr></table></figure></p>
<p>为什么都是false呢？这是因为我们实现的深拷贝后，2个对象是互相独立的，存储地址不同导致的结果。</p>
<p>对于string,number等基础类型，“==“ 和 ”===” 是有区别的。不同类型间比较，“==”会自动转换成同一类型后的值看“值”是否相等，“===“如果类型不同，其结果就是不等。</p>
<p>对于Array,Object等高级类型在比较相等时都会进行指针比较,所以”==”和”===”是没有区别的。</p>
<p>我们是现今是要比较这2份数据内容是否相同，而不是比较这2个对象，所以需要再转换成字符串比较<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(JSON.stringify(obj1) == JSON.stringify(obj2)) // true</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[闭包]]></title>
      <url>/2016/12/13/%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<h3 id="闭包-——-有权访问另一个函数作用域中的变量的函数"><a href="#闭包-——-有权访问另一个函数作用域中的变量的函数" class="headerlink" title="闭包 —— 有权访问另一个函数作用域中的变量的函数"></a>闭包 —— 有权访问另一个函数作用域中的变量的函数</h3><p>即要满足以下四个条件</p>
<ul>
<li>函数A套函数B</li>
<li>函数A中有一个变量a</li>
<li>函数B引用变量a</li>
<li>当函数B在定义它的作用域A以外的地方被调用时，它访问的依然是定义它时的作用域A。这种现象称之为闭包。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function A()&#123;</div><div class="line">  var a = 1;</div><div class="line">  </div><div class="line">  function B()&#123;</div><div class="line">    return a;</div><div class="line">  &#125;</div><div class="line">  return B;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var C=A();</div><div class="line">C();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>函数B嵌套在函数A内部；函数A返回函数B。这样在执行完var C=A( )后，变量C实际上是指向了函数B，再执行C( )后就会返回值a。这段代码其实就创建了一个闭包，因为函数A外的变量C引用了函数A内的函数B，也就是说：当函数A的内部函数B被函数A外的一个变量引用的时候，就创建了一个闭包。</p>
<h3 id="闭包的注意事项"><a href="#闭包的注意事项" class="headerlink" title="闭包的注意事项"></a>闭包的注意事项</h3><p>通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function makeAdder(x) &#123;</div><div class="line">  return function(y) &#123;</div><div class="line">    return x + y;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var add5 = makeAdder(5);</div><div class="line">var add10 = makeAdder(10);</div><div class="line"></div><div class="line">console.log(add5(2));  // 7</div><div class="line">console.log(add10(2)); // 12</div><div class="line"></div><div class="line">// 释放对闭包的引用</div><div class="line">add5 = null;</div><div class="line">add10 = null;</div></pre></td></tr></table></figure>
<blockquote>
<p>add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。最后通过 null 释放了 add5 和 add10 对闭包的引用。</p>
</blockquote>
<p>闭包closure()只能取得包含函数func()中任何变量的最后一个值，这是因为闭包所保存的是整个变量对象，而不是某个特殊的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function f()&#123;</div><div class="line">	var arr=[],i;</div><div class="line">	for(i=0;i&lt;3;i++)&#123;</div><div class="line">		arr[i] = function()&#123;</div><div class="line">			return i;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return arr;</div><div class="line">&#125;</div><div class="line">var func = f();</div><div class="line"></div><div class="line"></div><div class="line">&gt; func</div><div class="line">结果：[function, function, function]</div><div class="line">&gt; func[0]</div><div class="line">结果:   function ()&#123;</div><div class="line">            return i;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>为什么是 i 而不是具体某个值？</p>
<blockquote>
<p>主要是因为闭包中局部变量是【引用】而不是拷贝，也就是说，这个时候的i仅仅只是i的引用而不是i的值。而因为是i的引用，所以到了外部函数执行完毕后（i已经加到10了），这个时候，i才被赋值给result数组，而此时，i的值为10</p>
</blockquote>
<p>再举个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function say888() &#123;</div><div class="line">    var num = 887;</div><div class="line">    var sayAlert = function() &#123; alert(num); &#125;</div><div class="line">    num++;</div><div class="line">    return sayAlert;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say888() =&gt; 888</div></pre></td></tr></table></figure>
<p>如果要改变上面的那种情况，可以利用匿名函数的自我执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function createFunction ()&#123;</div><div class="line">    var result = new Array();</div><div class="line">    for(var i=0;i&lt;10;i++)&#123;</div><div class="line">        result[i] = function(num)&#123;</div><div class="line">    	    return function()&#123;</div><div class="line">    		return num;</div><div class="line">            &#125;</div><div class="line">	&#125;(i)</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这个时候的匿名函数相当于fn(0),fn(1),fn(2),<br>此时，数组result中保存的是函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">result[0]() = 0;</div><div class="line">result[1]() = 1;</div><div class="line">result[9]() = 9;</div></pre></td></tr></table></figure></p>
<p>因为这个时候的 i 只是函数参数，而函数参数是按值传递的（不是按引用传递），所以这个时候匿名函数被强制执行。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
